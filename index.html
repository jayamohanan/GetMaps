<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>q Kerala Administrative Boundaries Viewer</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; right: 0; left: 300px; }
    #panel-container { position: absolute; top: 0; bottom: 0; left: 0; width: 300px; background: #f7f7f7; border-right: 1px solid #ccc; overflow-y: auto; padding: 10px; }
    .panel { background: #fff; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
    .panel h3 { margin: 0 0 10px 0; font-size: 16px; }
    .panel label { display: block; margin-top: 5px; }
    .panel select, .panel input[type=text], .panel input[type=color], .panel input[type=range] { width: 100%; }
    .panel button { margin-top: 5px; width: 48%; }
    .panel .button-group { display: flex; justify-content: space-between; }
    .add-panel-btn { display: block; margin: 10px auto; padding: 5px 10px; cursor: pointer; }
  </style>
</head>
<body>

<div id="panel-container">
  <button class="add-panel-btn" onclick="addPanel()">+ Add Panel</button>
</div>
<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet Search for searchable dropdowns -->
<script src="https://unpkg.com/leaflet-search@3.0.2/dist/leaflet-search.src.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet-search@3.0.2/dist/leaflet-search.min.css"/>

<script>
let map = L.map('map').setView([10.8505, 76.2711], 7);

// Base maps
let baseMaps = {
  "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map),
  "OpenTopoMap": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17 }),
  "Blank": L.tileLayer('', { maxZoom: 19 })
};
L.control.layers(baseMaps).addTo(map);

// Store GeoJSON data
let geojsonData = {};
const geojsonFiles = {
  "State": "state_v15.2.geojson",
  "District": "district_V15.geojson",
  "Assembly": "assembly_V15.geojson",
  "Local body": "lsg_V15.geojson"
};

// Load GeoJSON files
for (let type in geojsonFiles) {
  fetch(geojsonFiles[type])
    .then(res => res.json())
    .then(data => { geojsonData[type] = data; })
    .catch(err => console.error(`Error loading ${type} data:`, err));
}

// Store drawn layers per panel
let panelLayers = [];

// Panel counter
let panelCount = 0;

// Panel creation function
function addPanel() {
  panelCount++;
  const panelContainer = document.getElementById('panel-container');
  
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.id = `panel-${panelCount}`;
  panel.innerHTML = `
    <h3>Panel ${panelCount}</h3>
    <label>Type:</label>
    <select onchange="onTypeChange(${panelCount}, this.value)">
      <option value="">Select Type</option>
      <option>State</option>
      <option>District</option>
      <option>Assembly</option>
      <option>Local body</option>
    </select>
    <label>Name:</label>
    <input type="text" id="name-${panelCount}" disabled placeholder="Select Type First"/>
    <div id="checkboxes-${panelCount}" style="display:none;">
      <label><input type="checkbox" id="parent-${panelCount}"> Parent(s)</label>
      <label><input type="checkbox" id="children-${panelCount}"> Children</label>
      <label><input type="checkbox" id="siblings-${panelCount}"> Siblings</label>
    </div>
    <label>Boundary Color:</label>
    <input type="color" id="color-${panelCount}" value="#000000"/>
    <label>Fill Transparency:</label>
    <input type="range" id="opacity-${panelCount}" min="0" max="1" step="0.1" value="0.5"/>
    <div class="button-group">
      <button onclick="drawBoundary(${panelCount})">Draw</button>
      <button onclick="clearBoundary(${panelCount})">Clear</button>
    </div>
  `;
  
  panelContainer.appendChild(panel);
}

// Type change handler
function onTypeChange(panelId, type) {
  const nameInput = document.getElementById(`name-${panelId}`);
  const checkboxDiv = document.getElementById(`checkboxes-${panelId}`);
  
  if (!type) {
    nameInput.disabled = true;
    checkboxDiv.style.display = 'none';
    return;
  }
  
  nameInput.disabled = false;
  checkboxDiv.style.display = 'block';
  
  // Auto-complete for name input
  const names = geojsonData[type] ? geojsonData[type].features.map(f => f.properties.Name) : [];
  nameInput.setAttribute('list', `list-${panelId}`);
  if (!document.getElementById(`list-${panelId}`)) {
    const datalist = document.createElement('datalist');
    datalist.id = `list-${panelId}`;
    panel.appendChild(datalist);
  }
  const datalist = document.getElementById(`list-${panelId}`);
  datalist.innerHTML = names.map(n => `<option value="${n}">`).join('');
}

// Draw boundary
function drawBoundary(panelId) {
  const panel = document.getElementById(`panel-${panelId}`);
  const type = panel.querySelector('select').value;
  const name = panel.querySelector(`#name-${panelId}`).value;
  const color = panel.querySelector(`#color-${panelId}`).value;
  const opacity = parseFloat(panel.querySelector(`#opacity-${panelId}`).value);
  const showParent = panel.querySelector(`#parent-${panelId}`).checked;
  const showChildren = panel.querySelector(`#children-${panelId}`).checked;
  const showSiblings = panel.querySelector(`#siblings-${panelId}`).checked;

  if (!geojsonData[type]) { alert("Data not loaded yet"); return; }
  
  // Find main feature
  let mainFeature = geojsonData[type].features.find(f => f.properties.Name === name);
  if (!mainFeature) { alert("Feature not found"); return; }
  
  let layersToAdd = [];
  
  // Helper function to add feature to layers
  function addFeatureLayer(feature, layerType) {
    const layer = L.geoJSON(feature, { style: { color: color, fillOpacity: opacity } }).addTo(map);
    layersToAdd.push(layer);
  }
  
  // Draw selected feature
  addFeatureLayer(mainFeature, type);
  
  // Hierarchy logic
  if (showParent || showChildren || showSiblings) {
    // Example logic for parents/children/siblings
    const lsgData = geojsonData["Local body"];
    const assemblyData = geojsonData["Assembly"];
    const districtData = geojsonData["District"];
    const stateData = geojsonData["State"];
    
    if (type === "State") {
      if (showChildren) {
        // Draw all districts/assemblies/lsg within the state
        if (districtData) districtData.features.forEach(f => addFeatureLayer(f, "District"));
        if (assemblyData) assemblyData.features.forEach(f => addFeatureLayer(f, "Assembly"));
        if (lsgData) lsgData.features.forEach(f => addFeatureLayer(f, "Local body"));
      }
    }
    if (type === "District") {
      if (showParent && stateData) stateData.features.forEach(f => addFeatureLayer(f, "State"));
      if (showChildren) {
        if (assemblyData) assemblyData.features.forEach(f => addFeatureLayer(f, "Assembly"));
        if (lsgData) lsgData.features.forEach(f => addFeatureLayer(f, "Local body"));
      }
      if (showSiblings && districtData) districtData.features.forEach(f => {
        if (f.properties.Name !== name) addFeatureLayer(f, "District");
      });
    }
    if (type === "Assembly") {
      if (showParent) {
        if (districtData) districtData.features.forEach(f => addFeatureLayer(f, "District"));
        if (stateData) stateData.features.forEach(f => addFeatureLayer(f, "State"));
      }
      if (showChildren && lsgData) lsgData.features.forEach(f => addFeatureLayer(f, "Local body"));
      if (showSiblings && assemblyData) assemblyData.features.forEach(f => {
        if (f.properties.Name !== name) addFeatureLayer(f, "Assembly");
      });
    }
    if (type === "Local body") {
      if (showParent) {
        if (assemblyData) assemblyData.features.forEach(f => addFeatureLayer(f, "Assembly"));
        if (districtData) districtData.features.forEach(f => addFeatureLayer(f, "District"));
        if (stateData) stateData.features.forEach(f => addFeatureLayer(f, "State"));
      }
      if (showSiblings && lsgData) lsgData.features.forEach(f => {
        if (f.properties.Name !== name) addFeatureLayer(f, "Local body");
      });
    }
  }
  
  // Save layers for this panel
  panelLayers[panelId] = layersToAdd;
}

// Clear boundary
function clearBoundary(panelId) {
  if (panelLayers[panelId]) {
    panelLayers[panelId].forEach(l => map.removeLayer(l));
    panelLayers[panelId] = [];
  }
}

// Initialize first panel on load
addPanel();

</script>
</body>
</html>
