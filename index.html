<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>1 Kerala Administrative Boundaries Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <!-- UI Styles -->
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #app { display: flex; height: 100vh; width: 100%; }
    #sidebar {
      width: 340px;
      background: #f7f7f7;
      border-right: 1px solid #ccc;
      padding: 10px;
      overflow-y: auto;
      transition: transform 0.3s ease;
    }
    #map { flex: 1; }
    .panel {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }
    label { display: block; margin: 6px 0 3px; }
    select, input[type="text"], input[type="color"], input[type="range"] {
      width: 100%; padding: 4px; margin-bottom: 8px;
    }
    button { margin: 5px 2px; padding: 6px 12px; cursor: pointer; }
    .hidden { display: none; }
    .loading { opacity: 0.6; pointer-events: none; }
    .error-popup {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: #fff; border: 1px solid #d33; padding: 12px 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 9999;
    }
    @media(max-width:768px){
      #sidebar {
        position: absolute;
        z-index: 1000;
        height: 100%;
        transform: translateX(-100%);
      }
      #sidebar.open { transform: translateX(0); }
      #toggleSidebar {
        position: absolute; top: 10px; left: 10px; z-index: 1100;
        background: white; border: 1px solid #ccc; padding: 5px 10px;
        cursor: pointer;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar"></div>
    <div id="map"></div>
  </div>
  <button id="toggleSidebar" class="hidden">☰ Menu</button>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ---------------------------
    // GLOBALS
    // ---------------------------
    let map;
    let baseMaps;
    let geojsonData = {};  // cached data
    let panelCount = 0;
    let panelLayers = {};  // stores layers per panel

    const files = {
      State: "state_V17.geojson",
      District: "district_V17.geojson",
      Assembly: "assembly_V17.geojson",
      "Local body": "lsg_V17.geojson"
    };

    const zIndexes = { State:100, District:200, Assembly:300, "Local body":400 };

    // ---------------------------
    // ERROR HANDLING
    // ---------------------------
    function showError(msg) {
      const div = document.createElement("div");
      div.className = "error-popup";
      div.innerHTML = `<p>${msg}</p><button onclick="this.parentNode.remove()">OK</button>`;
      document.body.appendChild(div);
    }

    // ---------------------------
    // INITIALIZE MAP
    // ---------------------------
    function initMap() {
      try {
        map = L.map("map").setView([10.8505, 76.2711], 7);

        const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "© OpenStreetMap" });
        const topo = L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", { attribution: "© OpenTopo" });
        const blank = L.tileLayer("", { attribution: "" });

        osm.addTo(map);

        baseMaps = { "OpenStreetMap": osm, "OpenTopoMap": topo, "Blank": blank };
        L.control.layers(baseMaps).addTo(map);

      } catch(e) {
        showError("Map failed to initialize. Please refresh the page");
        console.error(e);
      }
    }

    // ---------------------------
    // LOAD GEOJSON
    // ---------------------------
    async function loadGeoJSON(type) {
      if (geojsonData[type]) return geojsonData[type];
      try {
        const resp = await fetch(files[type]);
        if (!resp.ok) throw new Error("file not found");
        const data = await resp.json();
        geojsonData[type] = data;
        return data;
      } catch(err) {
        if (err.message.includes("file not found"))
          showError(`Data file ${files[type]} not found`);
        else
          showError(`Invalid data format in ${files[type]}. This layer will be skipped`);
        console.error(err);
        return { features: [] };
      }
    }

    // ---------------------------
    // CREATE PANEL
    // ---------------------------
    function createPanel() {
      panelCount++;
      const id = "panel" + panelCount;
      const div = document.createElement("div");
      div.className = "panel";
      div.id = id;
      div.innerHTML = `
        <h3>Panel ${panelCount}</h3>
        <label>Type</label>
        <select class="typeSelect">
          <option value="">--Select--</option>
          <option>State</option>
          <option>District</option>
          <option>Assembly</option>
          <option>Local body</option>
        </select>
        <label>Name</label>
        <input type="text" class="nameInput" placeholder="Search..."/>
        <div class="nameList"></div>
        <div class="relationships"></div>
        <label>Color</label>
        <input type="color" class="colorInput" value="#000000"/>
        <label>Transparency</label>
        <input type="range" min="0" max="100" value="0" class="transparencyInput"/>
        <div>
          <button class="drawBtn">Draw</button>
          <button class="clearBtn">Clear</button>
        </div>
      `;
      document.getElementById("sidebar").appendChild(div);

      setupPanelEvents(div, id);
    }

    // ---------------------------
    // PANEL EVENTS
    // ---------------------------
    function setupPanelEvents(panel, id) {
      const typeSelect = panel.querySelector(".typeSelect");
      const nameInput = panel.querySelector(".nameInput");
      const nameList = panel.querySelector(".nameList");
      const relDiv = panel.querySelector(".relationships");
      const drawBtn = panel.querySelector(".drawBtn");
      const clearBtn = panel.querySelector(".clearBtn");
      const colorInput = panel.querySelector(".colorInput");
      const transpInput = panel.querySelector(".transparencyInput");

      let selectedFeature = null;

      typeSelect.addEventListener("change", async () => {
        const type = typeSelect.value;
        if (!type) return;
        const data = await loadGeoJSON(type);
        const names = data.features.map(f => f.properties.Name);
        nameList.innerHTML = "";
        nameInput.disabled = false;
        nameInput.addEventListener("input", () => {
          const q = nameInput.value.toLowerCase();
          const filtered = names.filter(n => n.toLowerCase().includes(q));
          nameList.innerHTML = filtered.length
            ? filtered.map(n => `<div class="opt">${n}</div>`).join("")
            : "<div>No matches found</div>";
          [...nameList.querySelectorAll(".opt")].forEach(opt=>{
            opt.addEventListener("click",()=>{nameInput.value=opt.textContent; nameList.innerHTML="";});
          });
        });
      });

      drawBtn.addEventListener("click", async () => {
        const type = typeSelect.value;
        const name = nameInput.value.trim();
        if (!type || !name) { showError("Please select type and name first"); return; }
        panel.classList.add("loading");
        try {
          const data = await loadGeoJSON(type);
          const feat = data.features.find(f => f.properties.Name.toLowerCase() === name.toLowerCase());
          if (!feat) { showError(`No boundary found for '${name}' in ${type} data`); return; }
          selectedFeature = feat;

          const color = colorInput.value;
          const transp = transpInput.value;

          const layer = L.geoJSON(feat, {
            style: { color, weight:2, fillOpacity: transp/100 }
          }).addTo(map);
          layer.setZIndex(zIndexes[type]);

          if (!panelLayers[id]) panelLayers[id]=[];
          panelLayers[id].push(layer);

          map.fitBounds(layer.getBounds());
        } catch(e) {
          showError("Failed to draw boundary. Please try again");
          console.error(e);
        }
        panel.classList.remove("loading");
      });

      clearBtn.addEventListener("click", () => {
        if (panelLayers[id]) {
          panelLayers[id].forEach(l => map.removeLayer(l));
          panelLayers[id]=[];
        }
      });
    }

    // ---------------------------
    // INIT
    // ---------------------------
    window.onload = () => {
      initMap();
      createPanel();

      // Add New Panel Button
      const addBtn = document.createElement("button");
      addBtn.textContent = "+ Add New Panel";
      addBtn.onclick = createPanel;
      document.getElementById("sidebar").appendChild(addBtn);

      // Sidebar toggle for mobile
      const sidebar = document.getElementById("sidebar");
      const toggle = document.getElementById("toggleSidebar");
      if (window.innerWidth <= 768) toggle.classList.remove("hidden");
      toggle.onclick = ()=> sidebar.classList.toggle("open");
    }
  </script>
</body>
</html>
