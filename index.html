<script>
  // Map initialization
  let map;
  try {
    map = L.map('map').setView([10.8505, 76.2711], 7);
  } catch (e) {
    showError("Map failed to initialize. Please refresh the page");
  }

  // Base maps
  const baseMaps = {
    "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap'
    }),
    "OpenTopoMap": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenTopoMap'
    }),
    "Blank": L.tileLayer('', { attribution: '' })
  };

  baseMaps["OpenStreetMap"].addTo(map);
  L.control.layers(baseMaps).addTo(map);

  // GeoJSON cache
  const geojsonFiles = {
    state: "state_V17.geojson",
    district: "district_V17.geojson",
    assembly: "assembly_V17.geojson",
    lsg: "lsg_V17.geojson"
  };

  const geojsonData = {};
  const drawnLayers = {
    state: [],
    district: [],
    assembly: [],
    lsg: []
  };

  // Context menu container
  const contextMenu = document.createElement("div");
  contextMenu.style.position = "absolute";
  contextMenu.style.background = "white";
  contextMenu.style.border = "1px solid #444";
  contextMenu.style.padding = "10px";
  contextMenu.style.zIndex = "10001";
  contextMenu.style.display = "none";
  contextMenu.innerHTML = `
    <label>Color: <input type="color" id="ctx-color"></label><br>
    <label>Transparency: <input type="range" id="ctx-opacity" min="0" max="100"></label><br>
    <label>Thickness: <input type="range" id="ctx-weight" min="1" max="10"></label><br>
    <button id="ctx-close">Close</button>
  `;
  document.body.appendChild(contextMenu);

  let currentLayer = null;

  // Show context menu
  function openContextMenu(e, layer) {
    e.originalEvent.preventDefault();
    e.originalEvent.stopPropagation();

    currentLayer = layer;
    const style = layer.options;

    document.getElementById("ctx-color").value = style.color || "#000000";
    document.getElementById("ctx-opacity").value = (style.fillOpacity || 0) * 100;
    document.getElementById("ctx-weight").value = style.weight || 2;

    contextMenu.style.left = e.originalEvent.pageX + "px";
    contextMenu.style.top = e.originalEvent.pageY + "px";
    contextMenu.style.display = "block";
  }

  // Update styles from context menu
  document.getElementById("ctx-color").addEventListener("input", e => {
    if (currentLayer) {
      currentLayer.setStyle({ color: e.target.value, fillColor: e.target.value });
    }
  });

  document.getElementById("ctx-opacity").addEventListener("input", e => {
    if (currentLayer) {
      currentLayer.setStyle({ fillOpacity: e.target.value / 100 });
    }
  });

  document.getElementById("ctx-weight").addEventListener("input", e => {
    if (currentLayer) {
      currentLayer.setStyle({ weight: parseInt(e.target.value) });
    }
  });

  document.getElementById("ctx-close").addEventListener("click", () => {
    contextMenu.style.display = "none";
    currentLayer = null;
  });

  // Hide menu if clicking elsewhere
  map.on("click", () => {
    contextMenu.style.display = "none";
    currentLayer = null;
  });

  // Load GeoJSON files
  async function loadGeoJSON(type) {
    if (geojsonData[type]) return geojsonData[type];
    try {
      const res = await fetch(geojsonFiles[type]);
      if (!res.ok) throw new Error("not found");
      geojsonData[type] = await res.json();
      return geojsonData[type];
    } catch (e) {
      showError(`Data file ${geojsonFiles[type]} not found`);
      return null;
    }
  }

  // Draw boundaries
  async function drawBoundary(type, names, color, opacity) {
    const data = await loadGeoJSON(type);
    if (!data) return;

    names.forEach(name => {
      const feature = data.features.find(f => f.properties.Name.toLowerCase() === name.trim().toLowerCase());
      if (!feature) {
        showError(`No boundary found for '${name}' in ${type} data`);
        return;
      }

      try {
        const layer = L.geoJSON(feature, {
          style: {
            color: color,
            weight: 2,
            fillColor: color,
            fillOpacity: opacity / 100
          }
        }).addTo(map);

        // Attach context menu listener to each feature
        layer.eachLayer(l => {
          l.on("contextmenu", e => openContextMenu(e, l));
        });

        drawnLayers[type].push(layer);
      } catch (err) {
        console.error(err);
        showError("Failed to draw boundary. Please try again");
      }
    });
  }

  // Clear boundaries
  function clearBoundary(type) {
    drawnLayers[type].forEach(layer => map.removeLayer(layer));
    drawnLayers[type] = [];
  }

  // Handle buttons
  document.querySelectorAll(".input-group").forEach(group => {
    const type = group.dataset.type;
    const input = group.querySelector(".name-input");
    const colorInput = group.querySelector(".color-input");
    const transparencyInput = group.querySelector(".transparency-input");
    const drawBtn = group.querySelector(".draw-btn");
    const clearBtn = group.querySelector(".clear-btn");

    drawBtn.addEventListener("click", async () => {
      drawBtn.disabled = true;
      const spinner = document.createElement("span");
      spinner.classList.add("loading-spinner");
      drawBtn.appendChild(spinner);

      const names = input.value.split(",").map(x => x.trim()).filter(x => x);
      if (names.length > 0) {
        await drawBoundary(type, names, colorInput.value, transparencyInput.value);
      }

      drawBtn.disabled = false;
      spinner.remove();
    });

    clearBtn.addEventListener("click", () => {
      clearBoundary(type);
    });
  });

  // Error popup
  function showError(msg) {
    const popup = document.createElement("div");
    popup.className = "error-popup";
    popup.innerHTML = `<p>${msg}</p><button>OK</button>`;
    document.body.appendChild(popup);
    popup.querySelector("button").addEventListener("click", () => popup.remove());
    console.warn(msg);
  }
</script>
