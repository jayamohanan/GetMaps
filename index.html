<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>J Kerala Administrative Boundaries Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            background-color: #f5f5f5;
        }

        .sidebar {
            width: 350px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .sidebar h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 1.4rem;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .panels-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .input-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .panel-title {
            font-weight: bold;
            color: #333;
            font-size: 1.1rem;
        }

        .remove-panel {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .remove-panel:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        select, input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        select:disabled, input[type="text"]:disabled {
            background-color: #f8f9fa;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
            accent-color: #667eea;
        }

        .checkbox-item label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }

        .color-transparency-group {
            display: flex;
            gap: 15px;
            align-items: end;
        }

        .color-group {
            flex: 1;
        }

        .transparency-group {
            flex: 2;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            background: none;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 8px;
            accent-color: #667eea;
        }

        .transparency-value {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.4);
        }

        .add-panel-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .add-panel-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
            transform: translateY(-2px);
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .map-controls label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .map-controls select {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .error-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 400px;
            width: 90%;
            border-left: 5px solid #ff4757;
        }

        .error-popup h3 {
            color: #ff4757;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .error-popup p {
            color: #333;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .error-popup button {
            background: #ff4757;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
        }

        .loading {
            opacity: 0.7;
            pointer-events: none;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 50vh;
                order: 2;
            }
            
            .map-container {
                height: 50vh;
                order: 1;
            }
            
            .map-controls {
                top: 10px;
                right: 10px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h1>Kerala Administrative Boundaries Viewer</h1>
        <div class="panels-container" id="panelsContainer">
            <!-- Initial panel will be added by JavaScript -->
        </div>
        <div class="add-panel-btn" onclick="addPanel()">
            + Add New Panel
        </div>
    </div>

    <div class="map-container">
        <div class="map-controls">
            <label for="basemapSelect">Base Map:</label>
            <select id="basemapSelect" onchange="changeBaseMap()">
                <option value="osm">OpenStreetMap</option>
                <option value="topo">OpenTopoMap</option>
                <option value="blank">Blank</option>
            </select>
        </div>
        <div id="map"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        // Global variables
        let map;
        let panelCounter = 0;
        let geoJsonData = {
            state: null,
            district: null,
            assembly: null,
            lsg: null
        };
        let baseMaps = {};
        let currentBaseMap = null;
        const boundaryLayers = new Map(); // Store layers by panel ID

        // Z-index constants for layer ordering
        const Z_INDEX = {
            state: 100,
            district: 200,
            assembly: 300,
            lsg: 400
        };

        // Administrative hierarchy configuration
        const adminConfig = {
            'State': {
                file: 'state',
                children: ['District', 'Assembly', 'Local body'],
                parents: [],
                siblings: []
            },
            'District': {
                file: 'district',
                children: ['Assembly', 'Local body'],
                parents: ['State'],
                siblings: ['District']
            },
            'Assembly': {
                file: 'assembly',
                children: ['Local body'],
                parents: ['District', 'State'],
                siblings: ['Assembly']
            },
            'Local body': {
                file: 'lsg',
                children: [],
                parents: ['Assembly', 'District', 'State'],
                siblings: ['Local body']
            }
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            loadGeoJsonData();
            addPanel(); // Add initial panel
        });

        // Initialize Leaflet map
        function initMap() {
            try {
                map = L.map('map', {
                    zoomControl: true,
                    attributionControl: true
                }).setView([10.8505, 76.2711], 7); // Center on Kerala

                // Define base maps
                baseMaps.osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© OpenStreetMap contributors'
                });

                baseMaps.topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    maxZoom: 17,
                    attribution: '© OpenTopoMap contributors'
                });

                baseMaps.blank = L.tileLayer('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==', {
                    attribution: 'Blank Map'
                });

                // Set default base map
                currentBaseMap = baseMaps.osm;
                currentBaseMap.addTo(map);

            } catch (error) {
                showError('Map Initialization Error', `Failed to initialize map: ${error.message}`);
            }
        }

        // Change base map
        function changeBaseMap() {
            const select = document.getElementById('basemapSelect');
            const newBaseMap = baseMaps[select.value];
            
            if (currentBaseMap) {
                map.removeLayer(currentBaseMap);
            }
            
            currentBaseMap = newBaseMap;
            currentBaseMap.addTo(map);
        }

        // Load GeoJSON data
        async function loadGeoJsonData() {
            const files = {
                state: 'state_v15.2.geojson',
                district: 'district_V15.geojson',
                assembly: 'assembly_V15.geojson',
                lsg: 'lsg_V15.geojson'
            };

            for (const [key, filename] of Object.entries(files)) {
                try {
                    const response = await fetch(filename);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    geoJsonData[key] = await response.json();
                } catch (error) {
                    console.warn(`Failed to load ${filename}: ${error.message}`);
                    geoJsonData[key] = { type: "FeatureCollection", features: [] };
                }
            }
        }

        // Add new panel
        function addPanel() {
            panelCounter++;
            const panelId = `panel-${panelCounter}`;
            
            const panelHtml = `
                <div class="input-panel" id="${panelId}">
                    <div class="panel-header">
                        <span class="panel-title">Panel ${panelCounter}</span>
                        ${panelCounter > 1 ? `<button class="remove-panel" onclick="removePanel('${panelId}')">×</button>` : ''}
                    </div>
                    
                    <div class="form-group">
                        <label for="${panelId}-type">Type of Administrative Division:</label>
                        <select id="${panelId}-type" onchange="onTypeChange('${panelId}')">
                            <option value="">Select Type</option>
                            <option value="State">State</option>
                            <option value="District">District</option>
                            <option value="Assembly">Assembly</option>
                            <option value="Local body">Local body</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="${panelId}-name">Name:</label>
                        <select id="${panelId}-name" disabled>
                            <option value="">Select name after choosing type</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Related Boundaries:</label>
                        <div class="checkbox-group" id="${panelId}-checkboxes"></div>
                    </div>

                    <div class="color-transparency-group">
                        <div class="color-group">
                            <label for="${panelId}-color">Outline Color:</label>
                            <input type="color" id="${panelId}-color" value="#000000">
                        </div>
                        <div class="transparency-group">
                            <label for="${panelId}-transparency">Fill Opacity:</label>
                            <input type="range" id="${panelId}-transparency" min="0" max="1" step="0.1" value="0.3" oninput="updateTransparencyValue('${panelId}')">
                            <div class="transparency-value" id="${panelId}-transparency-value">30%</div>
                        </div>
                    </div>

                    <div class="action-buttons">
                        <button class="btn btn-primary" onclick="drawBoundaries('${panelId}')">
                            <span id="${panelId}-draw-text">Draw</span>
                            <span class="spinner hidden" id="${panelId}-spinner"></span>
                        </button>
                        <button class="btn btn-secondary" onclick="clearBoundaries('${panelId}')">Clear</button>
                    </div>
                </div>
            `;

            document.getElementById('panelsContainer').insertAdjacentHTML('beforeend', panelHtml);
        }

        // Remove panel
        function removePanel(panelId) {
            clearBoundaries(panelId);
            document.getElementById(panelId).remove();
        }

        // Handle type selection change
        function onTypeChange(panelId) {
            const typeSelect = document.getElementById(`${panelId}-type`);
            const nameSelect = document.getElementById(`${panelId}-name`);
            const checkboxContainer = document.getElementById(`${panelId}-checkboxes`);
            
            const selectedType = typeSelect.value;
            
            if (!selectedType) {
                nameSelect.disabled = true;
                nameSelect.innerHTML = '<option value="">Select name after choosing type</option>';
                checkboxContainer.innerHTML = '';
                return;
            }

            // Populate name dropdown
            populateNameDropdown(panelId, selectedType);
            
            // Create relationship checkboxes
            createRelationshipCheckboxes(panelId, selectedType);
            
            nameSelect.disabled = false;
        }

        // Populate name dropdown based on type
        function populateNameDropdown(panelId, type) {
            const nameSelect = document.getElementById(`${panelId}-name`);
            const config = adminConfig[type];
            
            if (!config || !geoJsonData[config.file]) {
                nameSelect.innerHTML = '<option value="">No data available</option>';
                return;
            }

            const features = geoJsonData[config.file].features;
            const names = features.map(feature => feature.properties.Name).filter(name => name).sort();
            
            nameSelect.innerHTML = '<option value="">Select name</option>';
            names.forEach(name => {
                nameSelect.innerHTML += `<option value="${name}">${name}</option>`;
            });
        }

        // Create relationship checkboxes
        function createRelationshipCheckboxes(panelId, type) {
            const checkboxContainer = document.getElementById(`${panelId}-checkboxes`);
            const config = adminConfig[type];
            
            if (!config) return;

            let checkboxHtml = '';
            
            // Parents
            if (config.parents.length > 0) {
                config.parents.forEach(parent => {
                    checkboxHtml += `
                        <div class="checkbox-item">
                            <input type="checkbox" id="${panelId}-parent-${parent.toLowerCase().replace(' ', '')}" value="${parent}">
                            <label for="${panelId}-parent-${parent.toLowerCase().replace(' ', '')}">${parent} (Parent)</label>
                        </div>
                    `;
                });
            }

            // Children
            if (config.children.length > 0) {
                config.children.forEach(child => {
                    checkboxHtml += `
                        <div class="checkbox-item">
                            <input type="checkbox" id="${panelId}-child-${child.toLowerCase().replace(' ', '')}" value="${child}">
                            <label for="${panelId}-child-${child.toLowerCase().replace(' ', '')}">${child} (Child)</label>
                        </div>
                    `;
                });
            }

            // Siblings
            if (config.siblings.length > 0) {
                config.siblings.forEach(sibling => {
                    checkboxHtml += `
                        <div class="checkbox-item">
                            <input type="checkbox" id="${panelId}-sibling-${sibling.toLowerCase().replace(' ', '')}" value="${sibling}">
                            <label for="${panelId}-sibling-${sibling.toLowerCase().replace(' ', '')}">${sibling} (Sibling)</label>
                        </div>
                    `;
                });
            }

            checkboxContainer.innerHTML = checkboxHtml;
        }

        // Update transparency value display
        function updateTransparencyValue(panelId) {
            const slider = document.getElementById(`${panelId}-transparency`);
            const valueDisplay = document.getElementById(`${panelId}-transparency-value`);
            const percentage = Math.round(slider.value * 100);
            valueDisplay.textContent = `${percentage}%`;
        }

        // Draw boundaries
        async function drawBoundaries(panelId) {
            const drawText = document.getElementById(`${panelId}-draw-text`);
            const spinner = document.getElementById(`${panelId}-spinner`);
            
            try {
                // Show loading state
                drawText.classList.add('hidden');
                spinner.classList.remove('hidden');
                document.getElementById(panelId).classList.add('loading');

                const type = document.getElementById(`${panelId}-type`).value;
                const name = document.getElementById(`${panelId}-name`).value;
                
                if (!type || !name) {
                    throw new Error('Please select both type and name');
                }

                const color = document.getElementById(`${panelId}-color`).value;
                const opacity = parseFloat(document.getElementById(`${panelId}-transparency`).value);

                // Clear existing boundaries for this panel
                clearBoundaries(panelId);
                
                // Initialize layer group for this panel
                if (!boundaryLayers.has(panelId)) {
                    boundaryLayers.set(panelId, new Map());
                }
                const panelLayers = boundaryLayers.get(panelId);

                // Draw main boundary
                await drawBoundaryType(panelId, type, name, color, opacity, 'main');

                // Draw related boundaries
                const checkboxes = document.getElementById(`${panelId}-checkboxes`).querySelectorAll('input[type="checkbox"]:checked');
                for (const checkbox of checkboxes) {
                    const relatedType = checkbox.value;
                    const relationship = checkbox.id.includes('parent') ? 'parent' : 
                                      checkbox.id.includes('child') ? 'child' : 'sibling';
                    
                    await drawRelatedBoundaries(panelId, type, name, relatedType, relationship, color, opacity * 0.5);
                }

                // Fit map to drawn boundaries
                if (panelLayers.size > 0) {
                    const allLayers = Array.from(panelLayers.values());
                    const group = L.layerGroup(allLayers);
                    map.fitBounds(group.getBounds(), { padding: [20, 20] });
                }

            } catch (error) {
                showError('Drawing Error', error.message);
            } finally {
                // Hide loading state
                drawText.classList.remove('hidden');
                spinner.classList.add('hidden');
                document.getElementById(panelId).classList.remove('loading');
            }
        }

        // Draw boundary for specific type
        async function drawBoundaryType(panelId, type, name, color, opacity, category) {
            const config = adminConfig[type];
            if (!config || !geoJsonData[config.file]) {
                throw new Error(`Data not available for ${type}`);
            }

            const features = geoJsonData[config.file].features.filter(
                feature => feature.properties.Name === name
            );

            if (features.length === 0) {
                throw new Error(`${name} not found in ${type} data`);
            }

            const panelLayers = boundaryLayers.get(panelId);
            
            features.forEach(feature => {
                const layer = L.geoJSON(feature, {
                    style: {
                        color: color,
                        weight: category === 'main' ? 3 : 2,
                        opacity: 1,
                        fillColor: color,
                        fillOpacity: opacity
                    },
                    onEachFeature: (feature, layer) => {
                        layer.bindPopup(`
                            <strong>${type}: ${feature.properties.Name}</strong><br>
                            ${Object.entries(feature.properties)
                                .filter(([key, value]) => key !== 'Name' && value)
                                .map(([key, value]) => `${key}: ${value}`)
                                .join('<br>')}
                        `);
                    }
                });

                // Set z-index for proper layering
                if (layer.setZIndex) {
                    layer.setZIndex(Z_INDEX[config.file] || 100);
                }

                layer.addTo(map);
                panelLayers.set(`${type}-${name}-${category}-${Date.now()}`, layer);
            });
        }

        // Draw related boundaries
        async function drawRelatedBoundaries(panelId, mainType, mainName, relatedType, relationship, color, opacity) {
            try {
                const relatedNames = await getRelatedNames(mainType, mainName, relatedType, relationship);
                
                for (const relatedName of relatedNames) {
                    await drawBoundaryType(panelId, relatedType, relatedName, color, opacity, relationship);
                }
            } catch (error) {
                console.warn(`Failed to draw related boundaries: ${error.message}`);
            }
        }

        // Get related names based on hierarchy
        async function getRelatedNames(mainType, mainName, relatedType, relationship) {
            const relatedNames = [];

            try {
                if (relationship === 'parent') {
                    relatedNames.push(...getParentNames(mainType, mainName, relatedType));
                } else if (relationship === 'child') {
                    relatedNames.push(...getChildNames(mainType, mainName, relatedType));
                } else if (relationship === 'sibling') {
                    relatedNames.push(...getSiblingNames(mainType, mainName, relatedType));
                }
            } catch (error) {
                console.warn(`Failed to get related names: ${error.message}`);
            }

            return relatedNames;
        }

        // Get parent names
        function getParentNames(childType, childName, parentType) {
            const parentNames = [];
            
            if (parentType === 'State') {
                parentNames.push('Kerala');
                return parentNames;
            }

            // For LSG, find parent assembly/district
            if (childType === 'Local body' && geoJsonData.lsg) {
                const lsgFeature = geoJsonData.lsg.features.find(f => f.properties.Name === childName);
                if (lsgFeature) {
                    if (parentType === 'Assembly' && lsgFeature.properties.Assembly) {
                        parentNames.push(lsgFeature.properties.Assembly);
                    } else if (parentType === 'District' && lsgFeature.properties.District) {
                        parentNames.push(lsgFeature.properties.District);
                    }
                }
            }

            // For Assembly, find parent district
            if (childType === 'Assembly' && parentType === 'District' && geoJsonData.lsg) {
                const relatedLsgs = geoJsonData.lsg.features.filter(f => f.properties.Assembly === childName);
                const districts = [...new Set(relatedLsgs.map(f => f.properties.District).filter(d => d))];
                parentNames.push(...districts);
            }

            return parentNames;
        }

        // Get child names
        function getChildNames(parentType, parentName, childType) {
            const childNames = [];

            if (childType === 'Local body' && geoJsonData.lsg) {
                let filterProp;
                if (parentType === 'District') filterProp = 'District';
                else if (parentType === 'Assembly') filterProp = 'Assembly';
                else if (parentType === 'State') filterProp = null; // All LSGs

                if (filterProp) {
                    const children = geoJsonData.lsg.features
                        .filter(f => f.properties[filterProp] === parentName)
                        .map(f => f.properties.Name)
                        .filter(name => name);
                    childNames.push(...children);
                } else if (parentType === 'State') {
                    const children = geoJsonData.lsg.features
                        .map(f => f.properties.Name)
                        .filter(name => name);
                    childNames.push(...children);
                }
            }

            if (childType === 'Assembly' && geoJsonData.lsg) {
                let assemblies;
                if (parentType === 'District') {
                    assemblies = [...new Set(geoJsonData.lsg.features
                        .filter(f => f.properties.District === parentName)
                        .map(f => f.properties.Assembly)
                        .filter(a => a))];
                } else if (parentType ===
